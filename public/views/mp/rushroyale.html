<!DOCTYPE html>
<html>
	<head>
		<link rel="stylesheet" type="text/css" href="/views/tetris.css" />
		<link rel="stylesheet" type="text/css" href="/views/mmp.css" />
		<style>
			@font-face {
				font-family: 'SilkScreen-Bold';
				src: url('/fonts/Silkscreen-Bold.ttf');
			}

			html,
			body,
			table,
			tr,
			th,
			td {
				font-family: 'SilkScreen-Bold', 'Press Start K', monospace;
			}

			.box {
				--border-size: 6;
				border-image-source: url('/views/black.webp');
			}

			.player {
				--p-row1-top: 40px;
				--p-row2-top: 540px;
				--p-left-x1: 60px;
				--p-left-x2: 720px;
				--p-offset: 380px;
				--p-video-width: 140px;

				top: var(--p-row1-top);

				transition: transform 0.6s ease-out;
			}

			.player .score {
				top: 0;
				height: 28px;
			}

			.player .score .value {
				font-size: 24px;
			}

			.player .board {
				top: 42px;
			}

			.player .video {
				--width: var(--p-video-width);
				--height: var(--p-video-width);
				width: var(--p-video-width);
				height: calc(var(--p-video-width) + 20px);
				background: black;
			}

			.player .name {
				position: absolute;
				top: var(--p-video-width);
				width: var(--p-video-width);
				color: #f3ed55;
				overflow: hidden;
			}

			.player .video video {
				background-size: cover;
				background-repeat: no-repeat;
			}

			.badges {
				position: absolute;
				width: var(--p-video-width);
				top: -20px;
				height: 44px;
				/* background-color: rgb(255, 255, 0, 0.5); */
				display: flex;
				justify-content: center;
				align-items: center;
				gap: 0.5em;
			}

			.badge {
				display: inline-block;
				width: 40px;
				height: 44px;
				overflow: hidden;
				color: black;
				font-size: 20px;
				text-align: center;
				line-height: 36px;
				background: url(/views/badge.bg.png);
				text-shadow: 1px 1px 1px;
			}

			.player.left .video {
				top: 0;
				left: 206px;
			}

			.player.right .video {
				top: 280px;
				left: -148px;
			}

			.player.first .rank_indicator {
				background: linear-gradient(rgb(0, 128, 0), rgb(0, 0, 0));
			}

			.player.penultimate .rank_indicator {
				background: linear-gradient(rgb(128, 78, 0), rgb(0, 0, 0));
			}

			.player.last .rank_indicator {
				background: linear-gradient(rgb(128, 0, 0), rgb(0, 0, 0));
			}

			.player.p1 {
				left: var(--p-left-x1);
			}
			.player.p2 {
				left: var(--p-left-x2);
			}
			.player.p3 {
				left: calc(var(--p-left-x1) + var(--p-offset));
			}
			.player.p4 {
				left: calc(var(--p-left-x2) + var(--p-offset));
			}
			.player.p5 {
				top: var(--p-row2-top);
				left: var(--p-left-x1);
			}
			.player.p6 {
				top: var(--p-row2-top);
				left: var(--p-left-x2);
			}
			.player.p7 {
				top: var(--p-row2-top);
				left: calc(var(--p-left-x1) + var(--p-offset));
			}
			.player.p8 {
				top: var(--p-row2-top);
				left: calc(var(--p-left-x2) + var(--p-offset));
			}

			.leaderboard {
				padding: 6px 18px;
				top: 20px;
				left: 1368px;
				width: 450px;
				height: 978px;
			}

			.leaderboard .header {
				font-size: 64px;
				line-height: 88px;
				padding-bottom: 1em;
				padding-top: 0.5em;
				font-family: 'Press Start K', monospace;
			}

			.leaderboard .value {
				columns: 1;
			}

			.leaderboard .value .entry {
				color: white;
				margin-bottom: 1.5em;
				position: absolute;
			}

			.leaderboard.avatar .value .entry {
				background-size: 66px 66px;
				background-repeat: no-repeat;
				padding-left: 74px;
			}

			.leaderboard.avatar .value .score2 {
				width: 180px;
			}

			.leaderboard.avatar .value .diff {
				width: 185px;
			}

			.leaderboard .value .entry.first {
				color: #0eff0e;
			}

			.leaderboard .value .entry.penultimate {
				color: #ffa500;
			}

			.leaderboard .value .entry.last {
				color: #fd0009;
			}

			.leaderboard .value .entry.eliminated {
				filter: grayscale(1) brightness(0.3);
			}

			.leaderboard .value .entry .name {
				display: block;
				text-align: left;
				width: 100%;
				padding-bottom: 0.15em;
			}

			@keyframes panic_colorize_wr {
				from {
					color: white;
				}
				to {
					color: red;
				}
			}

			.leaderboard.warn .header {
				animation: panic_colorize_wr 0.5s infinite;
				animation-direction: alternate;
			}

			.leaderboard.panic .header {
				animation: panic_colorize_wr 0.25s infinite;
				animation-direction: alternate;
			}

			.player.eliminated {
				filter: grayscale(1) brightness(0.3);
				/* transform: scale(0); */
			}
		</style>
	</head>
	<body>
		<div id="stream_bg">
			<div class="box leaderboard avatar">
				<div class="header">00.00</div>
				<div class="value"></div>
			</div>

			<template id="player">
				<div class="player">
					<div class="box video">
						<video class="player_vid"></video>
						<div class="name">hello</div>
						<div class="badges"></div>
					</div>

					<div class="box board">
						<div class="lines">000</div>
						<div class="next_piece"></div>
					</div>

					<div class="box score">
						<div class="value">0000000</div>
					</div>
				</div>
			</template>

			<template id="rank">
				<div class="entry">
					<span class="name">PLAYER</span>
					<span class="score2">0</span>
					<span class="diff">0</span>
				</div>
			</template>
		</div>
		<!-- End Stream BG -->

		<!-- Audio -->
		<script>
			// custom view parameters which will be passed in the websocket URI
			const view_meta = new URLSearchParams({
				video: '352x240',
				players: 8,
			});
		</script>
		<script src="/vendor/peerjs.1.5.4.min.js"></script>
		<script type="module">
			import '/views/bg.js';
			import QueryString from '/js/QueryString.js';
			import { peerServerOptions } from '/views/constants.js';
			import { translate, readableScoreFomatter, peek } from '/views/utils.js';
			import Player from '/views/Player.js';
			import Competition from '/views/competition.js';

			let adjusRankToID;

			const stream_bg = document.getElementById('stream_bg');
			const rank_template = document.getElementById('rank');
			const player_template = document.getElementById('player');
			const leaderboard = document.querySelector('.leaderboard');
			const leaderboard_values = document.querySelector('.leaderboard  .value');

			const rankYOffsets = [190, 292, 394, 496, 598, 700, 802, 904];

			if (QueryString.get('avatar') === '0') {
				leaderboard.classList.remove('avatar');
			}

			const players_re = /^[2345678]$/;
			const player_width = 228;
			const players = [];

			let num_players = 8;

			if (players_re.test(QueryString.get('players'))) {
				num_players = parseInt(QueryString.get('players'), 10);
			}

			const cycle_match = (QueryString.get('cycle') || '').match(
				/^[1-9]\d+,[1-9]\d+(,\d+,\d+)?$/
			);
			const cycle_settings = {
				initial_round: 90,
				subsequent_rounds: 60,
				warn: 16,
				panic: 8,
			};

			if (cycle_match) {
				const values = QueryString.get('cycle')
					.split(',')
					.map(v => parseInt(v, 10));
				if (!cycle_match[1]) {
					if (values[0] >= 10 && values[0] >= values[1]) {
						cycle_settings.initial_round = values[0];
						cycle_settings.subsequent_rounds = values[1];
					}
				} else {
					if (
						values[0] >= 10 &&
						values[0] >= values[1] &&
						values[0] >= values[2] &&
						values[2] >= values[3]
					) {
						cycle_settings.initial_round = values[0];
						cycle_settings.subsequent_rounds = values[1];
						cycle_settings.warn = values[2];
						cycle_settings.panic = values[3];
					}
				}
			}

			const rank_mode =
				QueryString.get('rank_mode') === 'score' ? 'score' : 'death'; // death is default

			// order by score, tdeath rank, and player index (?)
			function byScoreDescending(p1, p2) {
				const p1_score = p1.getScore();
				const p2_score = p2.getScore();

				if (p1_score === p2_score) {
					if (p1.death_rank == null) {
						if (p2.death_rank == null) {
							// both players still active, order by index
							return p1.idx - p2.idx;
						} else {
							// player 1 active, player 2 eliminated
							return -1;
						}
					} else {
						if (p2.death_rank == null) {
							// player 1 active, player 2 eliminated
							return 1;
						} else {
							// both players eliminated - order by rank
							return p1.death_rank - p2.death_rank;
						}
					}
				} else {
					return p2_score - p1_score;
				}
			}

			function getSortedPlayers() {
				const sorted_players =
					rank_mode === 'score'
						? [...players].sort(byScoreDescending)
						: [...players].sort((p1, p2) => {
								if (p1.death_rank == null) {
									if (p2.death_rank == null) {
										// both players still active
										return byScoreDescending(p1, p2);
									} else {
										// player 1 active, player 2 eliminated
										return -1;
									}
								} else {
									if (p2.death_rank == null) {
										// player 1 active, player 2 eliminated
										return 1;
									} else {
										// both players eliminated - order by rank
										return p1.death_rank - p2.death_rank;
									}
								}
						  });

				const active_players = sorted_players.filter(player => {
					if (rank_mode === 'score') {
						return !player.hasState('eliminated');
					} else {
						return !player.game?.over && !player.hasState('eliminated');
					}
				});

				return { sorted_players, active_players };
			}

			function updateScore() {
				let { sorted_players, active_players } = getSortedPlayers();

				// reset everything
				sorted_players.forEach((player, idx) => {
					player.removeStateClass('first', 'last', 'penultimate');
					player.dom.rank_node.targetTop = rankYOffsets[idx];
					player.dom.rank_node.querySelector('.diff').textContent = '';
				});

				if (rank_mode === 'score') {
					// in score mode, a score update may end the game: that happens on completing a chase down
					const alive_players = active_players.filter(
						player => !player.game?.over
					);

					if (alive_players.length === 1) {
						if (alive_players[0] === sorted_players[0]) {
							// it's a win! (chase down completion)
							active_players.forEach(player => {
								player.addStateClass('eliminated');
							});
							alive_players[0].addStateClass('first');
							alive_players[0].playWinnerAnimation();
							reset();
							return;
						}
					}

					// in score rank mode, topped out players who are at the bottom obviously cannot come back,
					// so they should be marked eliminated right away
					let needs_change = 0;
					for (let p_idx = sorted_players.length; p_idx--; ) {
						const player = sorted_players[p_idx];

						if (!player.game?.over) break;
						if (!player.hasState('eliminated')) {
							player.addStateClass('eliminated');
							needs_change += 1;
						}
					}

					if (needs_change) {
						startCycle(cycle_settings.subsequent_rounds * needs_change);
						const resorted = getSortedPlayers();
						sorted_players = resorted.sorted_players;
						active_players = resorted.active_players;
					}
				}

				if (active_players.length >= 2) {
					// grab all the tail players with the same score
					const lastPlayer = peek(active_players);
					const lastPlayerScore = lastPlayer.getScore();

					let cut_idx = active_players.length - 2;

					while (
						cut_idx >= 0 &&
						active_players[cut_idx].getScore() === lastPlayerScore
					)
						cut_idx--;

					if (cut_idx === -1) {
						// everyone is tied, they are all first place
						active_players.forEach(player => {
							player.addStateClass('first');
						});
					} else {
						// handled tied last players
						for (let idx = cut_idx + 1; idx < active_players.length; idx++) {
							const player = active_players[idx];

							player.addStateClass('last');
							player.dom.rank_node.querySelector('.diff').textContent =
								'DANGER';
						}

						// show score diff for anyone not tied for last
						for (let idx = cut_idx + 1; idx--; ) {
							const player = active_players[idx];
							const diff = player.getScore() - lastPlayerScore;

							player.dom.rank_node.querySelector('.diff').textContent =
								'+' + readableScoreFomatter(diff);
						}

						// show penutimate player
						if (cut_idx > 0) {
							sorted_players[cut_idx].dom.full_node.classList.add(
								'penultimate'
							);
							sorted_players[cut_idx].dom.rank_node.classList.add(
								'penultimate'
							);
						}

						// show tied first players
						const top_score = active_players[0].getScore();
						for (let idx = 0; idx < active_players.length; idx++) {
							const player = active_players[idx];

							if (player.getScore() < top_score) break;

							player.addStateClass('first');
						}
					}
				} else {
					sorted_players[0].addStateClass('first');
				}
			}

			let cycle_end_ts;
			let rafId;
			let toId;
			let cur_cycle_duration;
			let lvl19 = null;
			let lvl29 = null;
			let next_death_rank;

			function reset() {
				leaderboard.querySelector('.header').textContent = '-';
				leaderboard.classList.remove('warn', 'panic');

				toId = clearTimeout(toId);
				rafId = window.cancelAnimationFrame(rafId);
			}

			function roundInit() {
				lvl19 = lvl29 = null; // to track badges
				next_death_rank = players.length;

				players.forEach(player => {
					delete player.death_rank;

					player.removeStateClass(
						'eliminated',
						'first',
						'last',
						'penultimate',
						'topout'
					);

					player.dom.badges.replaceChildren();
				});
			}

			function startRound() {
				roundInit();
				startCycle(cycle_settings.initial_round);
				checkTime();
			}

			function checkTime() {
				const remainder = (cycle_end_ts - Date.now()) / 1000;
				let content = remainder.toFixed(2);

				if (remainder < cycle_settings.panic) {
					leaderboard.classList.remove('warn');
					leaderboard.classList.add('panic');
					content = `!${content}!`;
				} else if (remainder < cycle_settings.warn) {
					leaderboard.classList.add('warn');
					// content = `! ${content} !`;
				} else {
					leaderboard.classList.remove('warn', 'panic');
				}

				leaderboard.querySelector('.header').textContent = content;

				rafId = window.requestAnimationFrame(checkTime);
			}

			function startCycle(duration) {
				if (!duration) duration = cycle_settings.subsequent_rounds;

				toId = clearTimeout(toId);
				cycle_end_ts = Date.now() + duration * 1000;
				toId = setTimeout(endCycle, duration * 1000);
			}

			let endingCycle = false;

			function endCycle() {
				endingCycle = true;
				// figure out who to kick
				const num_kicked = kickPlayer();

				if (num_kicked) {
					updateScore();
					startCycle(cycle_settings.subsequent_rounds * num_kicked);
				} else {
					// round is over
					reset();
				}

				endingCycle = false;
			}

			function kickPlayer(topOutPlayer) {
				const { sorted_players, active_players } = getSortedPlayers();

				let cut_idx;

				// special handling for top out players to ensure the winner is shown
				if (topOutPlayer) {
					if (active_players.length === 1) {
						active_players[0].game?.end();
						active_players[0].playWinnerAnimation();
						reset();
					} else {
						startCycle();
					}

					return;
				}

				if (active_players.length == 1 && endingCycle) {
					// when there's just one active player at cycle end, then it was a chase down
					const player = active_players[0];
					player.game?.end();
					sorted_players[0].playWinnerAnimation();
					return;
				}

				if (active_players.length >= 2) {
					// grab all the tail players with the same score
					const lastPlayer = peek(active_players);
					const lastPlayerScore = lastPlayer.getScore();

					cut_idx = active_players.length - 2;
					while (active_players[cut_idx].getScore() === lastPlayerScore)
						cut_idx--;

					if (cut_idx === -1) {
						// tie victory!
						active_players.forEach(player => {
							player.game?.end();
							player.playWinnerAnimation();
						});
					} else {
						for (let idx = cut_idx + 1; idx < active_players.length; idx++) {
							const player = active_players[idx];

							player.game?.end();

							// must set alimited explicitly here (in addition than inside the gameover handler)
							// because player could be topped out, and so the gameover handler wouldn't run
							player.addStateClass('eliminated');
						}

						if (cut_idx === 0) {
							// we have a winner
							sorted_players[0].game?.end();
							sorted_players[0].playWinnerAnimation();
						} else {
							return active_players.length - cut_idx - 1; // return number of players kicked
						}
					}
				}
			}

			window.players = players;
			window.startRound = startRound;

			// Updating the rank positions at 60fps
			// TODO: don't animate when there's nothing to do
			function adjustRankPositions() {
				players.forEach(p => {
					const rank_node = p.dom.rank_node;

					if (rank_node.targetTop === rank_node.curTop) return;

					if (Math.abs(rank_node.targetTop - rank_node.curTop) < 0.0001) {
						rank_node.curTop = rank_node.targetTop;
					} else {
						rank_node.curTop = (rank_node.targetTop + rank_node.curTop) / 2;
					}

					rank_node.style.top = `${rank_node.curTop}px`;
				});
			}

			adjusRankToID = setInterval(adjustRankPositions, 1000 / 30);

			window.onload = () => {
				// wait for css
				const base_offset_y = 20;

				const players_stereo_source = {
					0: -1,
					1: 2 / 3,
					2: -2 / 3,
					3: 1,
					4: -1,
					5: 2 / 3,
					6: -2 / 3,
					7: 1,
				};

				Array(num_players)
					.fill()
					.forEach((_, player_idx) => {
						const player_fragment = document.importNode(
							player_template.content,
							true
						);
						const player_node = player_fragment.querySelector('.player');

						// simple formula to determine the type of video placement
						const video_alignment = (player_idx >> 1) % 2 ? 'right' : 'left';

						player_node.classList.add(`p${player_idx + 1}`, video_alignment);
						stream_bg.appendChild(player_node);

						const rank_fragment = document.importNode(
							rank_template.content,
							true
						);
						const rank_node = rank_fragment.querySelector('.entry');

						// initial display into the leaderboard
						rank_node.targetTop = rank_node.curTop = rankYOffsets[player_idx];
						rank_node.style.top = `${rank_node.curTop}px`;
						leaderboard_values.appendChild(rank_node);

						const player = new Player(
							{
								name: player_node.querySelector(`.name`),
								score: player_node.querySelector(`.score .value`),
								lines: player_node.querySelector(`.board .lines`),
								preview: player_node.querySelector(`.board .next_piece`),
								field: player_node.querySelector(`.board`),
								video: player_node.querySelector(`video`),
								badges: player_node.querySelector(`.badges`),

								full_node: player_node,
								rank_node,
							},
							{
								avatar: 1, // forced to 1 regardless or query string value, so we can hijack it for the CTK event logo
								field_pixel_size: 2.5,
								preview_pixel_size: 2,
								preview_align: 'tr',
								stereo: players_stereo_source[player_idx],
								format_score: readableScoreFomatter,
							}
						);

						player.addStateClass = function (...klasses) {
							this.dom.full_node.classList.add(...klasses);
							this.dom.rank_node.classList.add(...klasses);
						};

						player.removeStateClass = function (...klasses) {
							this.dom.full_node.classList.remove(...klasses);
							this.dom.rank_node.classList.remove(...klasses);
						};

						player.hasState = function (klass) {
							return this.dom.full_node.classList.contains(klass);
						};

						// adding extra properties to track
						player.idx = player_idx; // For stable sort -_-

						const rank_indicator = player.dom.field
							.querySelector('.background')
							.cloneNode();
						rank_indicator.classList.remove('background');
						rank_indicator.classList.add('rank_indicator');
						rank_indicator.style.display = 'block';

						player.dom.rank_indicator = rank_indicator;

						player.dom.field.prepend(rank_indicator);

						player.__setName = player.setName;
						player.setName = function (name) {
							this.__setName(name);
							this.dom.rank_node.querySelector('.name').textContent =
								name || '';
						};

						// show logo in background
						player.setAvatar('/images/ctk.webp');

						player.__setAvatar = player.setAvatar;
						player.setAvatar = function (url) {
							if (QueryString.get('avatar') === '0') return;
							// TODO Should validate that url is safe for string interpolation
							this.dom.video.style.backgroundImage = `url(${url})`;
							this.dom.rank_node.style.backgroundImage = `url(${url})`;

							// we're not calling the original avatar, because we don't want to show it the avatars in the play field
							// this.__setAvatar(url);
						};

						player.onGameStart = function () {
							this.dom.lines.hidden = false;
							this.dom.preview.hidden = false;
						};

						player.onGameOver = function () {
							this.death_rank = next_death_rank--;

							this.dom.lines.hidden = true;
							this.dom.preview.hidden = true;

							if (endingCycle) {
								this.addStateClass('eliminated');
							} else {
								this.addStateClass('topout');
								player.dom.rank_node.querySelector('.diff').textContent =
									'TOPOUT';

								if (rank_mode === 'death') {
									this.addStateClass('eliminated');

									updateScore();
									kickPlayer(this);
								}
							}
						};

						player._playWinnerAnimation = player.playWinnerAnimation;

						player.playWinnerAnimation = function () {
							this.removeStateClass('eliminated');
							this.dom.lines.hidden = true;
							this.dom.preview.hidden = true;
							player._playWinnerAnimation();
						};

						player.onLevel = function (frame) {
							if (frame.raw.level === 19) {
								if (lvl19) return;

								// first to 19!
								lvl19 = this;

								const badge = document.createElement('span');
								badge.classList.add('badge');
								badge.textContent = 19;

								player.dom.badges.appendChild(badge);
							} else if (frame.raw.level === 29) {
								if (lvl29) return;

								// first to 29!
								lvl29 = this;

								const badge = document.createElement('span');
								badge.classList.add('badge');
								badge.textContent = 29;

								player.dom.badges.appendChild(badge);
							}
						};

						players.push(player);
					});

				let countDownTimeoutId;
				const competition = new Competition(players, {
					startCountDown: function (seconds) {
						countDownTimeoutId = clearTimeout(countDownTimeoutId);
						reset();

						roundInit();

						this.__startCountDown(seconds);
						countDownTimeoutId = setTimeout(startRound, seconds * 1000);

						leaderboard.querySelector('.header').textContent =
							cycle_settings.initial_round.toFixed(2);
					},
				});

				players.forEach(player => {
					player.onScore = () => {
						player.dom.rank_node.querySelector('.score2').textContent =
							readableScoreFomatter(player.getScore());
						updateScore();
					};
				});

				window.competition = competition;

				updateScore();
			};

			if (/^\/replay\//.test(location.pathname)) {
				startRound();
			}

			// TODO: hijack countdown API to be a startRound()
		</script>
	</body>
</html>
